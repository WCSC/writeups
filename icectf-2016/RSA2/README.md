# IceCTF 2016 RSA 2
## Solution By: Nullp0inter

# RSA2 Cryptography 90 pts

I guess the 3rd time is the charm? Or not... flag.txt

# Solution:

For this challenge we were given a text file that contained the following:

```
N=0xee290c7a603fc23300eb3f0e5868d056b7deb1af33b5112a6da1edc9612c5eeb4ab07d838a3b4397d8e6b6844065d98543a977ed40ccd8f57ac5bc2daee2dec301aac508f9befc27fae4a2665e82f13b1ddd17d3a0c85740bed8d53eeda665a5fc1bed35fbbcedd4279d04aa747ac1f996f724b14f0228366aeae34305152e1f430221f9594497686c9f49021d833144962c2a53dbb47bdbfd19785ad8da6e7b59be24d34ed201384d3b0f34267df4ba8b53f0f4481f9bd2e26c4a3e95cd1a47f806a1f16b86a9fc5e8a0756898f63f5c9144f51b401ba0dd5ad58fb0e97ebac9a41dc3fb4a378707f7210e64c131bca19bd54e39bbfa0d7a0e7c89d955b1c9f
e=0x10001
c=0x3dbf00a02f924a70f44bdd69e73c46241e9f036bfa49a0c92659d8eb0fe47e42068eaf156a9b3ee81651bc0576a91ffed48610c158dc8d2fb1719c7242704f0d965f8798304925a322c121904b91e5fc5eb3dc960b03eb8635be53b995217d4c317126e0ec6e9a9acfd5d915265634a22a612de962cfaa2e0443b78bdf841ff901423ef765e3d98b38bcce114fede1f13e223b9bd8155e913c8670d8b85b1f3bcb99353053cdb4aef1bf16fa74fd81e42325209c0953a694636c0ce0a19949f343dc229b2b7d80c3c43ebe80e89cbe3a3f7c867fd7cee06943886b0718a4a3584c9d9f9a66c9de29fda7cfee30ad3db061981855555eeac01940b1924eb4c301
```

So we have three variable `N`, `e`, and `c`, but what do we do with them. Well in RSA `N` is what is known as your "public modulus" and is obtained by multiplying your two primes `p` and `q`, `c` is what is
known as our cipher text which was obtained by using the RSA algorithm on our plaintext message. If you want to learn more about the specifics of RSA you can chekc them out on [wikipedia](https://en.wikipedia.org/wiki/RSA_(cryptosystem) "RSA").
The important thing to know is that to decrypt the message we have to obtain `d` and for that we need to know `p` and `q` which means getting the prime factorization of `N`. There are a few utilities that
do this for us, thankfully: you can use the online tool at [factordb](www.factordb.com "factor db") OR you can use [YAFU](https://sourceforge.net/projects/yafu/ "Yet Another Factoring Utility") which is what
I did and recommend. Using yafu we can factor our N into p and q like so:

```python
ing GMP-ECM 6.4.4, Powered by GMP 5.1.1
detected Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz
detected L1 = 32768 bytes, L2 = 134217728 bytes, CL = 64 bytes
measured cpu frequency ~= 2194.754630
using 20 random witnesses for Rabin-Miller PRP checks

===============================================================
======= Welcome to YAFU (Yet Another Factoring Utility) =======
=======             bbuhrow@gmail.com                   =======
=======     Type help at any time, or quit to quit      =======
===============================================================
cached 78498 primes. pmax = 999983


>> N=0xee290c7a603fc23300eb3f0e5868d056b7deb1af33b5112a6da1edc9612c5eeb4ab07d838a3b4397d8e6b6844065d98543a977ed40ccd8f57ac5bc2daee2dec301aac508f9befc27fae4a2665e82f13b1ddd17d3a0c85740bed8d53eeda665a5fc1bed35fbbcedd4279d04aa747ac1f996f724b14f0228366aeae34305152e1f430221f9594497686c9f49021d833144962c2a53dbb47bdbfd19785ad8da6e7b59be24d34ed201384d3b0f34267df4ba8b53f0f4481f9bd2e26c4a3e95cd1a47f806a1f16b86a9fc5e8a0756898f63f5c9144f51b401ba0dd5ad58fb0e97ebac9a41dc3fb4a378707f7210e64c131bca19bd54e39bbfa0d7a0e7c89d955b1c9f

invalid destination N

ans = 30064958471180141352963255964320727764941087854957385562672821662319854021395100968823341108075020928542437446993994119863902565874355296188498304761389336438421889636409561936141985786801002923752627293790265351723795968412774268086467114263767947693310444934316205390814185802517514694528501333851255084653925181726978734804806707740444755908398751964899143494522781405457103697373868972836201511424363601490903086488506985489526910314474245106338585623571369549388434865567951986866445306840505397268281889886738015891982162371413136885989746931929787765617838750381226036784122498143172854419447324975505933540511

>> factor(30064958471180141352963255964320727764941087854957385562672821662319854021395100968823341108075020928542437446993994119863902565874355296188498304761389336438421889636409561936141985786801002923752627293790265351723795968412774268086467114263767947693310444934316205390814185802517514694528501333851255084653925181726978734804806707740444755908398751964899143494522781405457103697373868972836201511424363601490903086488506985489526910314474245106338585623571369549388434865567951986866445306840505397268281889886738015891982162371413136885989746931929787765617838750381226036784122498143172854419447324975505933540511)

    fac: factoring 30064958471180141352963255964320727764941087854957385562672821662319854021395100968823341108075020928542437446993994119863902565874355296188498304761389336438421889636409561936141985786801002923752627293790265351723795968412774268086467114263767947693310444934316205390814185802517514694528501333851255084653925181726978734804806707740444755908398751964899143494522781405457103697373868972836201511424363601490903086488506985489526910314474245106338585623571369549388434865567951986866445306840505397268281889886738015891982162371413136885989746931929787765617838750381226036784122498143172854419447324975505933540511
    fac: using pretesting plan: normal
    fac: no tune info: using qs/gnfs crossover of 95 digits
    div: primes less than 10000
    fmt: 1000000 iterations
    rho: x^2 + 3, starting 1000 iterations on C617 
    rho: x^2 + 2, starting 1000 iterations on C617 
    Total factoring time = 0.3202 seconds


    ***factors found***

    P8 = 57970027
    PRP609 = 518629368090170828331048663550229634444384299751272939077168648935075604180676006392464524953128293842996441022771890719731811852948684950388211907532651941639114462313594608747413310447500790775078081191686616804987790818396104388332734677935684723647108960882771460341293023764117182393730838418468480006985768382115446225422781116531906323045161803441960506496275763429558238732127362521949515590606221409745127192859630468854653290302491063292735496286233738504010613373838035073995140744724948933839238851600638652315655508861728439180988253324943039367876070687033249730660337593825389358874152757864093

    ans = 1
```

so we have our p and q and now we just need to compute d. To do so we need to compute `phi` where phi = (p-1)(q-1), so using python:

```python
p = 57970027
q = 518629368090170828331048663550229634444384299751272939077168648935075604180676006392464524953128293842996441022771890719731811852948684950388211907532651941639114462313594608747413310447500790775078081191686616804987790818396104388332734677935684723647108960882771460341293023764117182393730838418468480006985768382115446225422781116531906323045161803441960506496275763429558238732127362521949515590606221409745127192859630468854653290302491063292735496286233738504010613373838035073995140744724948933839238851600638652315655508861728439180988253324943039367876070687033249730660337593825389358874152757864093
p_1 = p - 1
q_1 = q - 1 
phi = p_1 * q_1
```

In order to find d we need to calculate the modular inverse of c and phi. We can do this in python with a little bit of code found on [stackoverflow](http://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-pyt "Modular Multiplicative Inverse in Python").
Putting it into the script we get the following which spits out d:

```python
#!/usr/bin/python

# egcd and modinv functions from: http://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
e = int(0x10001)
p = 57970027
q = 518629368090170828331048663550229634444384299751272939077168648935075604180676006392464524953128293842996441022771890719731811852948684950388211907532651941639114462313594608747413310447500790775078081191686616804987790818396104388332734677935684723647108960882771460341293023764117182393730838418468480006985768382115446225422781116531906323045161803441960506496275763429558238732127362521949515590606221409745127192859630468854653290302491063292735496286233738504010613373838035073995140744724948933839238851600638652315655508861728439180988253324943039367876070687033249730660337593825389358874152757864093
p_1 = p - 1
q_1 = q - 1 
phi = p_1 * q_1
d = modinv(e,phi)
print hex(d)
```

From there you can either do the math in python or just provide your c and d values to the tool [here](http://nmichaels.org/rsa.py "Online RSA Tool") which gives back the flag in hex format
which means all you need to do is convert hex to ascii which again is pretty easy and can be done online [here](http://www.rapidtables.com/convert/number/hex-to-ascii.htm "Online Hex to ASCII converter") if you are feeling lazy.

For your effort you are rewarded with the flag: `IceCTF{next_time_check_your_keys_arent_factorable}`


For convenience because either I am terrible at searching or no one has bothered to make one very easily visible, I have written a small python script that asks for e, p, and q then solves for your d and returns it in hex format. Feel free to use it.
